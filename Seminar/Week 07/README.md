# Статични елементи. Изключения.

<slidebreak/>

## Статични локални променливи

- Статичните локални променливи се инициализират само веднъж, при първото влизане в scope-a, в който са дефинирани.
- Животът на статичните локални променливи продължава до края на програмата, а не до излизане от scope-a, в който са дефинирани. 

```cpp
int foo()
{
    static int x = 0;
    return ++x;
}

int main()
{
    // 1 2 3 4 5
    for (int i = 0; i < 5; i++)
    {
        std::cout << foo() << " "; 
    }
}
```

<slidebreak/>

## Статични функции
- Статичните функции са функции, които са достъпни само в рамките на файла, в който са дефинирани.

```cpp
// Test.cpp
static int foo() { return 42; }
int bar() { return 42; }

// main.cpp
int main()
{
    // error: 'int foo()' was declared 'static' and was declared 'static' in another translation unit
    // foo();
    bar();
}
```

<slidebreak/>

## Статични членове на клас

- Статичните член-данни не са обвързани с конкретен обект, а с класа като цяло. Тях може да си ги мислим като статични променливи, декларирани в namespace. За да ги достъпим използваме scope resolution оператора `::`. Инициализират се ЗАДЪЛЖИТЕЛНО извън класа.
- Статичните член-функции не са обвързани с конкретен обект, а с класа като цяло. Те не могат да достъпват нестатични член-данни на класа (защото няма обект, над който се изпълняват, няма this). Извикват се чрез scope resolution оператора `::`. Те може да достъпват статични член-данни на класа.

```cpp
class Test
{
public:
    static int x;
};

class AnotherTest
{
    int x;
public:
    static int y;

    static void print()
    {
        // std::cout << this->x << std::endl; // there is no object => no this
        // std::cout << x << std::endl; // there is no global variable x neither static class member x, neither local variable x
        std::cout << y << AnotherTest::y << Test::x << std::endl;
    }
}

int Test::x = 42;
int Test::y = 0;

int main()
{
    std::cout << Test::x << std::endl;
    AnotherTest::print();
    AnotherTest::y = 42;
    AnotherTest::print();
}
```

<slidebreak/>

## Кога използваме статични членове на клас
- Като статични член функции на класа е удобно да се ползват например помощни функции, които не работят с конкретен обект, тоест не достъпват и променят член-данните на класа. Друг пример са factory методите, които създават обекти от текущия клас.
- Като статични член-данни на класа е удобно да се ползват например генератори на уникални идентификатори, кеширане за даден вид обекти, броячи на състояние и т.н. За тези случаи разбира се, е удобно да се работи със статични член-функции.

<slidebreak/>

## Error handling / Exception handling
- При писането на код често възниква нуждата от връщане на резултат, сигнализиращ за грешка (например некоректен вход, некоректен индекс и т.н.).
- Може да се използват различни подходи за обработка на грешки, като някои са:
    - Използване на семантични обекти с резултатите от изпълнението
    - Използване на по-широки типове, които да поддържат "невалидни" стойности
    - Използване на generic механизми като optional, error-or и други
- Използването на изключения (exceptions) е друг механизъм за обработка на грешки. При него имаме възможност за отделяне на логиката по обработка на грешката, като не се интересуваме от конкретния контекст на възникване на грешката.

<slidebreak/>

- При възникване на грешка "хвърляме" (`throw`) изключение, а при обработка на грешката "хващаме" (`catch`) изключението. Изключенията могат да бъдат от произволни типове, но е добре да се използват само обекти, които наследяват* от `std::exception`.
- Ако имаме код, който може да хвърли изключение, то той трябва да бъде поставен в `try` блок. След него следва един или повече `catch` блока, които обработват хвърленото изключение.
- Може да имаме много на брой catch блокове, които да хващат различни типове изключения. Отгоре надолу се проверяват всички catch блокове докато се намери съвпадение, след което се влиза в съответния блок и останалите блокове не се проверяват за възможно съвпадение. Важно е да се внимава с реда на catch блоковете, тъй като по-общите catch блокове трябва да са по-долу от по-специфичните.
- Като последен catch блок може да се използва `catch(...)`, който хваща всички изключения, които не са хванати до момента. Той трябва да е последен, тъй като е най-общия catch блок.

<slidebreak/>

```cpp
class Test {};

void error(int n)
{
    if (n < 0)
    {
        throw n;
    }
}

int main()
{
    try
    {
        error(-1); // the code that might throw an exception
    }
    catch (int n)
    {
        std::cerr << "Caught int: " << n << std::endl;
    }
    catch(const Test& t) // when we catch an exception of non-primitive type -> always const reference
    {
        std::cerr << "Caught Test exception" << std::endl;
    }
    catch (...) // Catch any exception without knowledge of its type
    {
        std::cerr << "Caught unexpected exception." << std::endl;
    }
}
```

<slidebreak/>

- При хвърляне на изключение, текущата функция се прекратява и се проверява дали текущата функция или някоя от извикващите функции нагоре по стека може да се справи с изключението (има try-catch блок). Ако бъде намерен съответстващ блок за обработка на изключение, изпълнението се прескача от момента, в който е хвърлено изключението, до началото на съответстващия блок за обработка. Това изисква stack unwinding (премахване на текущата функция от стека на повикванията) толкова пъти, колкото е необходимо, за да може функцията, обработваща изключението, да бъде най-горе в call stack-а. Когато текущата функция се премахне от call stack-а, всички успешно създадени локални променливи се унищожават както обикновено, но не се връща стойност.
- Ако не може да бъде намерен блок за обработка на изключение за дадена функция, се извиква std::terminate() и програмата се прекратява. Не е задължително стекът да бъде разгънат, тоест може локалните променливи да не бъдат унищожени.

<slidebreak/>

```cpp
void unsafe()
{
    X x;
    throw 42;
}

void middleware() {
    A obj1;
    B obj2;
    unsafe();
    C obj3;
}

int main() {
    try
    {
        middleware(); // ~X() ~B() ~A()
    }
    catch (int n) 
    {
        // Handle the exception
    }
    catch (...) 
    {
        // In this example we won't reach this block, because the exception is already handled in the previous catch block
    }    
}
```

<slidebreak/>

## Йерархия на изключенията

`std::exception` - основен клас за всички изключения в C++, който предоставя метод `what()`, който връща съобщение за грешката. Негови наследници са:
- `std::bad_alloc` - грешка при заделяне на памет
- `std::bad_cast` - грешка при кастване
- `std::runtime_error` - грешка по време на изпълнение - например при опит за деление на 0, извикване на невалиден индекс и т.н. (която от своя страна има наследници като `std::overflow_error`, `std::underflow_error`, `std::range_error` и т.н.)
- `std::logic_error` - грешка, която нарушава инвариантите на класа (условията, които трябва да са изпълнени) и може да бъде предотвратена (която от своя страна има наследници като `std::invalid_argument`, `std::out_of_range`, `std::domain_error`, `std::length_error` и т.н.)

<slidebreak/>

- Когато искаме да имаме някакви конкретни изключения, произлизащи семантично от нашият контекст на програмата, можем да създадем свои собствени класове, наследяващи от `std::exception` или от някой от неговите наследници. Важно е да предефинираме метода `what()`, за да можем да получим информация за грешката. *
- Когато подреждаме catch блоковете, класовете по-нагоре в йерархията трябва да са по-надолу, защото са по-общи и хващат повече видове грешки

```cpp
void f(int n)
{
    if (n < 0)
    {
        throw std::invalid_argument("Number should be positive!");
    }
}

int main()
{
    try
    {
        f();
    }
    catch (std::invalid_argument& e)
    {
        std::cerr << e.what() << std::endl;
    }
    catch (std::logic_error& e)
    {
        std::cerr << e.what() << std::endl; // Probably handle sth differently :)
    }
    catch (std::exception& e) 
    {
        std::cerr << e.what() << std::endl;
    }    
    catch (...) {
        std::cout << "Unknown exception!" << std::endl;
    }
}
```

<slidebreak/>

## Някои особености

- Относно хвърлянето на изключения в контруктор - при хвърляне на изключение се изчиства паметта само за успешно създадените обекти, което означава, че ако заделяме памет в heap-a в конструктор и възникне грешка в конструктора, то тази заделена памет при създаването на обекта трябва да я изтрием ръчно, защото деструктора за този обект, при чието създаване възниква изключението няма да бъде извикан. Деструкторите се извикват само за успешно създадените обекти.

```cpp
class X 
{
    A a;
    B b;
    char* first_name;
    char* last_name;

public:
    X(/*...*/) : a(/*...*/), b(/*...*/)
    {
        first_name = new char[...]; // if it doesn't allocate => no problem
        strcpy(...);
        try {
            last_name = new char[...]; // if it fails to allocate => we have to delete first_name as it is already allocated, but no destructor will be called to handle that memory leak
            // The destructors of A (for a) and B (for b) will be called (because they are successfully created already using the member initializer list), but not of X, because it is not successfully created
            strcpy(...);
        }
        catch(std::std::bad_alloc& ex) {
            delete[] first_name;
        }
    }
}
```

<slidebreak/>

- Относно хвърлянето на изключения в деструктор - НИКОГА, понеже при stack unwinding, деструкторите на обектите от текущата стек рамка ще бъдат извикани и ако в деструктора хвърлим изключение, то ще се получи второ изключение. В такъв случай програмата ще бъде прекратена с `std::terminate()`, защото в даден момент програмата може да поддържа само едно изключение. Деструкторът винаги е `noexcept`, тоест не може да хвърля изключение. 

<slidebreak/>

## Exception guarantees

- Nothrow (nofail) guarantee - функцията никога няма да хвърли изключение -> `noexcept`
- Strong exception guarantee - ако функция хвърли изключение, състоянието на програмата ще е същото, както преди да се извика функцията (тоест се revert-ват всички евентуални промени върху обекта).
- Basic exception guarantee - възможно е да се хвърли изключение и обектът ще може да се ползва (тоест е във валидно за използване състояние), но не се гарантира, че ще бъде в същото състояние, в което е било преди извикване на функцията (нямаме гаранция, че промените, довели до грешката ще бъдат revert-нати).
- No exception guarantee - няма гаранция за нищо

<slidebreak/>

## Задача

Моделирайте университет, който предлага обучение по дадени специалности, всяка от които има фиксиран набор от курсове, които се водят на студентите. В университета могат да се записват студенти, като дадено лице може да се обучава по не повече от 1 специалност в даден момент. Университетът пази информация за всички студенти и преподаватели в него - ЕГН (уникално), име, възраст. Преподавателите имат набор от курсове, които водят, а студентите набор от оценки за курсовете от специалността им и факултетен номер (уникален). За всеки студент и преподавател трябва да може да се изведе информация за него, както и фиксиран брой статистики по желание. Данните на системата трябва да се съхраняват във файл. При стартиране на системата, трябва да има възможност за зареждане на данните от съществуващ файл или да се стартира с празна система. 

