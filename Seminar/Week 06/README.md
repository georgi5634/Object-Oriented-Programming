# Приятелски функции и класове. Предефиниране на оператори.

<slidebreak/>

## Приятелски функции и класове

- Приятелските функции и класове са такива, които имат достъп до ***всички*** членове на друг клас, дори които са обявени като `private` или `protected`.
- Приятелите се обявяват в тялото на класа, като се използва ключовата дума `friend`, пред декларация на клас или функция.
- Обикновено декларациите за приятелски функции пишем в публичната част на класа.

```cpp
class A
{
private:
    int a;

public:
    friend class B;
    friend void foo();
};

class B
{
    int b;
public:
    void bar(A& a)
    {
        a.a = 42;
    }
};

void foo()
{
    A a;
    a.a = 42;
}
```

<slidebreak/>

- Ако A има за приятел B, това не означава, че B има за приятел A. (Хората, които мисля за приятели, не е задължително да са ми приятели) -> приятелството не е симетрична релация.
- Ако А има за приятел B и B има за приятел C, това не означава, че А има за приятел C.(Приятелите на моите приятели не са ми приятели) -> приятелството не е транзитивна релация.
- Ако А има за приятел B и B има дете C, то C няма да е приятел на А. (Децата на моите приятели не са ми приятели).

<slidebreak/>

## Малко за приятелските класове

Приятелските класове може да се ползват за релации от типа на:
- Книга - Библиотека
- Човек - Банка
- Кола - Автокъща

Въпреки, че изглеждат като нещо удобно, тяхната употреба е рядко най-доброто решение. Заради третото свойство на нетранзитивност при наследяването, приятелството създава силни зависимости (strong coupling) и нарушава абстракцията. Всяко нещо, за което може да ползваме friend може да се моделира по друг начин, който не го изисква. В някакви случаи употребата му е чисто породена от желание за улеснение на работата. Приятелски класове може да се използват за тестване на класове, но това е друга дълга тема.

Ако не сме сигурни дали приятелският клас е решението, което ни трябва, може да пробваме първо решението без friend. Като разбира се, ако решението ни включва оставяне на публични членове (тоест нарушаване на капсулацията), които не е добре да са такива, стигаме до приятелски клас.

<slidebreak/>

## Малко за приятелските функции

Приятелските функции най-често са полезни за предефиниране на оператори за класове, които не са наша собственост. Това е един от най-честите случаи, в които се използват приятелски функции.

Друг случай, в който може да се наложи употребата на приятелски функции, е когато искаме да имаме външна функция (която семантично трябва да е външна) и да има достъп до членовете на класа.

И двата случая на употреба на приятелски функции, могат да бъдат решени и чрез употребата на публичен интерфейс, като трябва да се внимава да не се наруши капсулацията на класа.

<slidebreak/>

## Предефиниране на оператори

- Операторите в C++ са функции със специално име `operator<оператор>`.
- Операторите се характеризират с приоритет, асоциативност,брой аргументи и позиция спрямо аргументите си.
- Може да се предефинират всички оператори, с изключение на следните:
    - `::` (scope resolution)
    - `.`  (member access)
    - `.*` (member access through pointer to member)
    - `?:` (ternary conditional)
- Не може да се дефинират нови оператори, различни от съществуващите в езика
- Когато предефинираме оператори, може да го правим като външна функция или като член функция на класа. Когато операторът е член функция, текущият обект е левият операнд.

<slidebreak/>

- Извикване на операторите, където @ е произволен оператор оператор:

| Оператор | Синтаксис  като  член функция | Синтаксис като външна функция |
|----------|-----------|-----------|
|@a|	(a).operator@ ( )		| operator@ (a)
|a@b|	(a).operator@ (b)	| operator@ (a, b)
|a@	|(a).operator@ (0)	|	operator@ (a, 0)
|a[b...]|	(a).operator[](b...)	| не
|a=b|	(a).operator= (b)	|не	
|a(b...)|	(a).operator()(b...)|	не
|a->|(a).operator->( )| не	

<slidebreak/>

- За различиване на префиксен и постфиксен оператор ++ и --, се използват допълнителен параметър в декларацията на функцията при постфиксните оператори.
- За операторите, които имат варианти за унарни и бинарни оператори с един и същ символ (например `+`,`-`, `&`, `*`) може да се предефиниран, като бройката параметри определя кой оператор влиза в употреба.
- С изключение на function call оператора operator(), всички предефинирани оператори приемат параметри.

```cpp
class Foo
{
public:
    int a;
    void b() {}
};

// Member access to pointer member operator example
int main()
{
    Foo foo;

    int (Foo::*ptr);
    ptr = &Foo::a;
    foo.*ptr = 42; // foo.a = 123;

    void(Foo:: * func)();
    func = &Foo::b;
    (foo.*func)(); // foo.b();
}
```

<slidebreak/>

## Кога и как да предефинираме какви оператори

- Когато предефинираме оператори за клас, трябва да взимаме предвид как работят оригиналните оператори, защото потребителите на нашия клас ще очакват същото поведение.
- Ако предефинираме даден оператор, трябва да предефинираме и всички свързани оператори, за да се запази семантиката на езика. В такива групи оператори, когато сме дефинирали един от операторите може да предефинираме чрез него и останалите.
- За определяне на това дали операторът да се предефинира като външна функция(ако оператора е различен от `=`,`[]`,`()`,`->`) или член функция, може да гледаме дали операторът модифицира даден обект, върху който е приложен, или връща нов обект. Ако операторът модифицира обекта, той трябва да бъде дефиниран като член функция. В противен случай, той трябва да бъде дефиниран като външна функция. 
- Когато предефинираме оператор за вече съществуващ клас (ляв аргумент), който да използва нашия клас, може да го направим единствено като външна функция.
- Когато даден оператор е дефиниран като външна функция, ако имаме нужда от достъп до непубличните членове на класа, може да го декларираме като приятелска функция.

<slidebreak/>

- Аритметичните оператори, които променят обекта, ще дефинираме като член функции, а останалите, които връщат нов обект за резултат, като външни функции. При външните функции лесно се ползват съставните оператори, които сме дефинирали като член функции.

```cpp
// Member function operator overloading
Complex& Complex::operator+=(const Complex& other)
{
	real += other.real;
	im += other.im;
	return *this;
}

// Non-member function operator overloading
Complex operator+(const Complex& lhs, const Complex& rhs)
{
	Complex temp(lhs); // Creating a local copy for the result
	temp+=rhs; // Using the already definded operator
	return temp; // Returning the result
}
```

<slidebreak/>

- Ако класът изисква проверка за равенство, то се дефинира оператора ==. Той трябва еднозначно да определя дали два обекта са равни, като запазва транзитивността на равенството и да запазва своето отрицание.
- Ако класът изисква някакъв вид наредба, то предифинираме оператор `<`, а чрез него и останалите релационни оператори.

```cpp
// Having declared the below functions as frineds in the class Complex

bool operator==(const Complex& lhs, const Complex& rhs)
{
	return (lhs.real==rhs.real && lhs.im==rhs.im);
}

bool operator!=(const Complex& lhs, const Complex& rhs)
{
	return !(lhs==rhs);
}
```

<slidebreak/>

- Ако се извършват входно-изходни операции, то се дефинират shift операторите << и >>.

```cpp
// Having declared the below functions as frineds in the class Complex

std::ostream& operator<<(std::ostream& os, const Complex& r)
{
	return os << r.real << "+" << r.im << "i";
}

std::istream& operator>>(std::istream& is, Complex& r)
{
	return is >> r.real >> r.im;
}
```

<slidebreak/>

## Задачи

- Работа с комплексни числа
- Разширение на имплементациите на низ и масив
- Имплементация на вектор