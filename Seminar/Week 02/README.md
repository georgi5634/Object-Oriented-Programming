# Работа с файлове

<slidebreak/>

## Потоци

- Безкрайна поредица от байтове
- Входни и изходни потоци - `std::istream`, `std::ostream`
- Стандартен вход, изход, грешка - потоци с номера 0,1,2 - `std::cin`, `std::cout`, `std::cerr`

<slidebreak/>

## Работа с файлови потоци

- Библиотеката `fstream`
- `std::ifstream` - наследник на `std::istream` - за четене от файл
- `std::ofstream` - наследник на `std::ostream` - за писане във файл

- Потоците пазят релативна позиция къде се извършват операциите в даден момент, тоест имат "указател към текущия байт"

- Файловете може да ги разглеждаме като тестови или двоични. Тестовите файлове са двоични файлове, при които диапазонът от стойности на байтовете е ограничен в тестово-четимия

- При работа с файлове винаги първо отваряме файла(`open` или чрез *конструктора*), като специфицираме режима на работа. Винаги трябва да проверим дали файлът е отворен успешно с `is_open` и да го затворим, след като сме приключили работа с `close`

- Форматиран вход и изход от файлове, подобно на стандартните потоци
- `get()` и `put(char)` за четене и писане на символ
- `read(char*, size)` и `write(const char*, size)` - за четене и писане на множество ***байтове***

<slidebreak/>

## Режими за работа

- `ios::in` - отваря за четене
- `ios::out` - отваря за писане (+ на произволно място), НО изтрива съдържанието, ако файлът съществува 
- `ios::ate` - отваря за писане (+ на произволно място)
- `ios::app` - отваря за писанe, НО само в края на файла
- `ios::trunc` - изтрива съдържанието, ако файлът съществува
- `ios::binary` - отваря в двоичен режим
- `ios::_Nocreate` - отваря за писане, НО само ако файлът съществува
- `ios::_Noreplace` - отваря за писане, НО само ако файлът НЕ съществува

> [!NOTE]
> Всеки режим е  константа - цяло число, степен на 2, което ни позволява с побитово ИЛИ да комбинираме режимите (където това има смисъл). Горната подредба отговаря на степените на двойката, започвайки от 0

Може да имаме и поток `std::fstream`, който е за едновременно четене и писане във файла, но по-скоро не е за предпочитане

<slidebreak/>

## Позициониране във файл

- `tellg()` - връща позицитията на текущия символ в потока за четене
- `tellp()` - връща позицитията на текущия символ в потока за писане
- `seekg(offset, direction)` или `seekg(streampos idx)` - премества get-указателя на потока за четене
- `seekp(offset, direction)` или `seekp(streampos idx)` - премества put-указателя на потока за писане.

> [!NOTE]
> `offset` (число) е отместването от `direction` (може да има стойности `ios::beg`(спрямо началото), `ios::cur`(спрямо текущата позиция), `ios::end`(спрямо края))

<slidebreak/>

## Състояние на потока

Функции с булеви стойности, указващи: 

- `bad()` - някоя операция по четене или писане е неуспешна
- `fail()` - последната операция е неуспешна
- `good()` - всички операции са успешни
- `clear()` - изчистваме състоянието на потока
- `eof()` - достигнат край на потока

<slidebreak/>

## Работа с файлове - C-style

Библиотеката `cstdio` ни позволява да работим с указатели към обекти от тип `FILE` ->  https://cplusplus.com/reference/cstdio/

Повечето функции връщат положителен статус код при успешна операция и `EOF` статус код (по принцип -1) при неуспешна операция (ако не връщат нещо друго).

Тук имаме един пойнтър към потока и при смесване на операции за четене и писане, както и преместване в потока, трябва да се прави flush

<slidebreak/>

Основни функции:

- `FILE* fopen(filename, mode)` - отваря файл в даден режим и връща `FILE*`, където `mode` е низ:
    - `"r"` - отваря за четене, като файлът трябва да съществува
    - `"w"` - отваря за писане, като създава нов файл
    - `"a"` - отваря за писане, САМО в края на файла
    - добавяне на `"+"` - отваря файла едновременно за четене и писане и позволява update на съдържанието, спазвайки горните особености
    - добавяне на `"b"` - отваря файла в двоичен режим 
- `int fclose(FILE*)` - затваря файла
- `int fflush(FILE*)` - извършва операциите, съхранени в буфера

<slidebreak/>

Функции за форматиран вход и изход:

- `int fprintf(FILE*, format, args...)` - писане на форматиран низ
- `int fscanf(FILE*, format, args...)` - четене на форматиран низ

Някои форматиращи спецификатори:
- `d` - decimal integer
- `c` - character
- `s` - string
- `f` - floating-point number

Пример: `fprintf(file, "%s:%d\n", "Hello", 127);`

<slidebreak/>

Функции за четене и писане:
- `int fgetc(FILE* file)`
- `char* fgets(char* buffer, int size, FILE* file)`
- `int fputc(int character, FILE* file)`
- `int fputs(const char* string, FILE* file)`

- `size_t fwrite(const void* ptr, size_t size, size_t count, FILE* file)` - записва масив от count на брой елемента, всеки с големина size, като началото на масива е ptr - удобно, когато не се използва динамична памет. Връща броя записани елементи (трябва да е колкото count)
- `size_t fread(void* ptr, size_t size, size_t count, FILE* file)` - аналогично на горното, но чете 

<slidebreak/>

Функции за състоянието на файла:
- `int ferror(FILE*)` - 0 ако няма грешка
- `int feof(FILE*)`- 0 ако няма грешка

Функции за позициониране във файл:
- `void rewind(FILE*)` - връщане в началото на файла
- `long ftell(FILE*)` - текущата позиция в потока
- `int fseek(FILE* file, long offset, int origin)` - връща 0 при успех, отмества на отстояние offset спрямо origin:
    - `SEEK_SET` - началото на файла
    - `SEEK_CUR` - текущата позиция във файла
    - `SEEK_END` - края на файла

- Други: `remove(filename)`, `rename(oldname, newname)`

<slidebreak/>

## Работа с двоични файлове

Процеса по запис и четене са процес по сериализация и десериализация на данните. Поредицата на четене е точно същата, която е използване при писане. Когато се работи със статични данни и масиви, може да записваме директно тяхното съдържение. Когато се работи с динамични данни, е необходимо да записваме самите данни, а не указателя към тях (нямаме ползва от някакъв временен адрес). Когато става въпрос за данимични масиви трябва да запишем и броя елементи в масива, за да знаем при четенето колко елемента искаме да прочетем.

> [!NOTE]
> Файловете са поредица от байтове, поради което примитивите за работа с байтове изискват указатели към тип `char` - който отговаря на един байт

> [!NOTE]
> При работата с файлове, предназначение за съхранение на някаква информация, в общия случай имаме четене на съдържанието на файла, обработка на информацията и запис на обработената информация в същия или друг файл. Не се извършва модификация на съдържанието на файла директно.

<slidebreak/>

## Задачи

**Задача (общи):** Големина на файл

**Задача (общи):** Брой срещания във файл

**Задача (общи):** Брой записи във файл

**Задача (текстови файлове):** Да се напиша програма, която прочита път до CSV файл, който съдържа информация за студенти - всеки студент има име, фн, имейл. Да се поддържат заявки за търсене на студент по фн, като се извежда информацията за него, както и промяна на данните на студент по фн - промяна на името или имейла. Да може да се запише обновената информация във файл по подаден път.

**Задача (двоични файлове):** Да се напиша програма, която управлява студентски данни. При стартиране на програмата да има опция да се създаде нов файл с данни или да се зареди съществуващ такъв. Да има опции за добавяне и изтриване на студентски запис (има, имейл, фн). Да може да се променя информацията за студент. Да може да се извежда и търси в наличната информация. Да се записва информацията във файл.
