# Класове и обекти. Членове. Конструктор и деструктор. Капсулация и абстракция.

<slidebreak/>

## Същност

- Моделираме света чрез обекти
- Обектите са описани от класове - там са всички техни характеристики
- Посредством описанието в класа създаваме обекта
- Обектите имат вътрешно състояние
- Обектите имат и външно видими характеристики
- Обектите могат да взаимодействат помежду си
- Можем да създаваме и унищожаваме обекти

<slidebreak/>

## Капсулация

- Обединяване на състоянието с начините за промяна
- Нуждата от изолация на вътрешното състояние на обекта и разкриването на определен интерфейс за достъп и промяна на обекта
- Изискване за използване на достъпните начини за взаимодействие с обекта, без пряко да се нарушава вътрешното му състояние - тоест се използват дефиниранте от обекта начини за неговата модификация, а не директно
    - Например човекът има интерфейс за приемана на храна и течности и последващото отделяне на непотрабената част, като няма директен достъп до вътрешните органи, на които да предоставя необходимите вещества в суров вид и да взима ненужните
    - С този пример разбира се може да задълбочим като кажем, че както хирург може да оперира човека и да има директен достъп до органите на човека, така и програмиста може да наруши установената капсулация, ако иска да го направи, въпрос на спазване на нормите е 

<slidebreak/>

- Има 3 модификатора за достъп, които контролират кой какви членове може да достъпва
    - `private`: само членовете на обекта могат да достъпват тези членове
    - `protected`: само членовете на обекта и членовете на наследниците могат да достпнат тези членове
    - `public`: всички могат да достъпнат тези членове

Тези модификатори се ползват като label-и в тялото на класа и се отнасят до всички членове, които следват до следващия модификатор или края на класа, като може да се ползват множество пъти

> [!NOTE]
> Втрешното състояние на класа трябва да е максимално капсулирано - само при необходимост правим нещо `public`, с ясното съзнание, че то е необходим интерфейс, с който външният свят да взаимодейства с нас

<slidebreak/>

## Обекти vs Записи

- От техническа гледна точка разликата им е областта на видимост на членовете по подразбиране:
    - `public` за структурите
    - `private` за класовете
- От семантична гледна точка:
    - класовете са описания на обекти - behavioral objects
    - структурите са описания на записи - data-transfer objects

> [!NOTE]
> В курса по ООП ще ползваме класове

<slidebreak/>

## Член-данни

- Данните, асоциирани с обекта
- Представляват неговото вътрешно състояние
- Променливи от произволен тип

<slidebreak/>

## Член-функции

- Функции, които са декларирани в тялота на класа
- Те се прилагат над обекти от дадения клас
- Компилаторът ги преобразува до самостоятелни функции с един допълнителен параметър - константен указател към обекта, на име `this` (ние никога НЕ го добавяме изрично `this`)
- Дефинициите на функциите не е задължително да живеят в тялото на класа

```cpp
class Number {
public:
    int x;

    bool isNegative() {
        return x < 0;
    }

    bool isPositive();
    bool areEqual(int);
};

bool Number::isPositive() {
    return x > 0;
}
```

Функцията се създава като външна по следния начин от компилатора:
```cpp
bool Number::isPositive(Number* const this) {
    return this->x > 0;
}
```

<slidebreak/>

- Това не означава, че не можем да си ползваме `this` в тялото на функцията
- Употребата на `this` е задължителен когато искаме да достъпим променлива на обекта, но в дадената функция имаме друга променлива със същото име, която скрива тази от обекта

```cpp
bool Number::areEqual(int x)
{
    return x == this->x;
}
```

При извикване на функцията:
```cpp
Number n = {10};
std::cout << number.areEqual(5);
```
Компилаторът го трансформира до:
```cpp
Number n = {10};
std::cout << Number::areEqual(5, &number);
```

<slidebreak/>

## Конструктор и деструктор
- Специални член-функции, които се викат точно по веднъж - конструкора в началото на жизнения цикъл на обекта, а деструктора в края на живота на обекта
- Жизненият цикъл започва от заделянето на памет за обекта - създаването на статичен или динамичен обект и приключва когато заделената памет се освободи - обекта се унищожава
- Конструктора има същото име като класа и няма експлицитно зададен тип на връщане - връща константна референция. Използва се за задаване на началното вътршно състояне на обекта - тоест на членовете му. Винаги има поне 1 конструктор
- Деструктора има същото име като като класа, предшествано с тилда `~`. Няма експлицитно указан тип на връщане - не връща нищо. Винаги има точно 1 деструктор

> [!IMPORTANT]
> Ако няма експлицитно създадени конструктор и деструктор компилаторът създава такива по подразбиране

<slidebreak/>

- В конструктора може да ползваме member initializer list за задаване на стойности на параметрите или да ги задаваме в тялото на конструктора - това са извиквания на конструктори - или на примитивни типове или на наши дефинирани типове
- Може да имаме множество конструктори и от даден конструктор да извикваме друг такъв

```cpp
class Number {
    int x;

public:

    Number(int x) : x(x) // Member initializer list
    {
        std::cout << "Constructor with x" << std::endl;
    }

    // Default constructor takes no params
    Number() : Number(0)
    {
        std::cout << "Default contructor called" << std::endl;
    } 

    ~Number()
    {
        std::cout << "Destructor" << std::endl;
    }
};
```

> [!IMPORTANT]
> Когато искаме да създаваме масиви от обекти, трябва класа на обекта ЗАДЪЛЖИТЕЛНО да има конструктор по подразбиране


<slidebreak/>

## Константни и мутиращи членове
- Дадена член-променлива може да е `const` и това означава, че нейната стойност не може да се променя по време на жизнения цикъл на обекта
- Дадена член-функция може да е `const` и това означава, че тя не променя вътрешното състояние на обекта
- Дадена член-променлива може да е `mutable` и това означава, че тя може да се променя, дори в константен контекст

```cpp
class Test {
    const int x = 0;
    mutable int y = 0;
    int z = 0;

public:
    void mutate() {
        // x++; - error (const)
        y++;
        z++;
        nonMutable();
    }

    void nonMutable() const {
        // x++; - error (const)
        y++; // ok - mutable
        // y++; - error (not mutable)
        // mutate(); - error (not const)
    }
};


int main() {
    Test t1;
    t1.mutate();
    t1.nonMutable();

    const Test t2;
    // t2.mutate(); - error - mutate is not const but t2 is
    t2.nonMutable();
}
```

> [!IMPORTANT]
> `mutable` се ползва много внимателно и само и единствено за непреки данни за състоянието на обекта - например някакъв вид кеширане или отразяване на събития.

<slidebreak/>

## Селектори и мутатори

- Селектори - функции за достъп до вътрешното състояние на обекта - обикновено връщат константни указатели или копия на данни, задължително константни член-функции
- Мутатори - функции за промяна на вътрешното състояние на обекта - обикновено правят валидация на промяната на състоянието

```cpp
class Number {
    int x;

public:
    Number():Number(0) {}
    Number(int x): x(x){}

    int getNumber() const { return x; }
    void setNumber(long long x) { 
        if(INT_MIN <= x && x <= INT_MAX)
            this->x = x;
    }
}
```

<slidebreak/>


## Примери

```cpp
class Test
{
    int* dynVar;
    int x;

    Test(int x) : x(x)
    {
        dynVar = new int(x);
    }

    ~Test()
    {
        delete dynVar;
    }

};

int main()
{
    Test t1(5);
    Test* t2 = new Test(10);
    
    {
        Test t3(20);
    }

    delete t2;

    Test* t4 = new Test[30];
}
```

<slidebreak/>


## Задачи

***Задача:*** Да се моделира клас Time за работа със зададено време - час, минути, секунди. Той да позволява конвертирането към и от секунди, намиране на разлика на два зададени часа, увеличаване на времето с даден брой секунди, както и функция, която връща част от деня, в която е дадения час (сутрин, обед, вечер, нощ).

***Задача:*** Да се моделира клас PrimeIterator, който
- Има конструктор по подразбиране
- Има конструктор, приемащ начало на итерирания интервал
- Има конструктор, приемащ начало и край на итерирания инетрвал
- Функция next, която премества итератора на следващото просто число и го връща
- Функция current, която взима стойността на текущото итерирано просто число
- Функция hasNext, която казва дали има следващо число от итерирания интервал