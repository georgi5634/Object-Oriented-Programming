# Масиви от указатели към обекти.

<slidebreak/>

## Конвертиращ конструктор

- Когато имаме конструктор с точно един аргумент и този аргумент е от тип, различен от типа на класа, който дефинираме, този конструктор се нарича конвертиращ конструктор.
- Конвертиращият конструктор позволява на компилатора да конвертира аргумента от типа, който е подаден на конструктора, до типа на класа, който дефинираме.
- Ако искаме да имаме конструктор с един аргумент, който да не може да се използва като конвертиращ конструктор, трябва да го декларираме като `explicit`.

```cpp
class Empty {};

class Test {
    int x;
public:
    Test(int x) : x(x) {}
    explicit Test(double x) : x(x) {}
    explicit Test(Empty x) : x(0) {}
};

int main() 
{
    Test t = 5; // Converting Constructor
    Test t2 = 5.5; // Ok: double is first converted to int, then converting constructor
    Test t3(5); // Convering constructor accepting int
    Test t3(5.5); // Convering constructor accepting double
    Test t4 = Empty(); //Error: Converting constructor is explicit
    Test t4(Empty()); //Ok: Converting constructor is explicit
}
```

<slidebreak/>

## Някои особености

```cpp
class Test {
private:
    // Compile error: Destructor is private
    ~Test() { }
};

class Test2 {
public:
    Test2() {}
    // Compile error: Copy constructor can't have parameter of type Test2
    // should be Test&!
    Test2(const Test2 t) {}
};

class Test3 {
    // Compiler error: Incomplete type is not allowed
    Test3 test;
};
```

<slidebreak/>

## Масиви от указатели към обекти

- Статичен масив от обекти - заделя се памет на стека, задължително трябва конструктор по подразбиране и фиксиран размер на масива.

```cpp
class Test;
int main()
{
	Test arr[5];
} 
```

<slidebreak/>

- Статичен масив от указатели към обекти - заделя се памет на стека за указатели, няма нужда от конструктор по подразбиране, винаги фиксиран размер на масива. След това всеки обект се заделя на хийпа.

```cpp
class Test;
int main() 
{
	Test* arr[5] = {};
	
	arr[0] = new Test();
	arr[2] = new Test();
	
	delete arr[0];
	delete arr[2];
}
```

<slidebreak/>

- Динамичен масив от обекти - заделя се памет на хийпа, задължително трябва конструктор по подразбиране и размерът на масива е произволен и променлив.

```cpp
class Test;
int main()
{
	Test* arr = new Test[5];
	delete[] arr;
} 
```

<slidebreak/>

- Динамичен масив от указатели към обекти - заделя се памет на хийпа за указатели, няма нужда от конструктор по подразбиране, размерът на масива е произволен и променлив. След това всеки обект се заделя на хийпа.

```cpp
class Test;

int main()
{
	Test** arr = new Test*[5];
	
	arr[0] = new Test();
	arr[2] = new Test();
	
	delete arr[0];
	delete arr[2];
	
	delete[] arr;
}
```

<slidebreak/>

При масивите от указатели към обекти получаваме оптимизации при swap и resize, защото се разменят само стойности на указатели, а не се копират цели обект. При този случай не се изисква конструктор по подразбиране. Също така, не се изисква излишна памет за обектите, които все още не ползваме в масива, като може да има и дупки в масива (nullptr). Недостъците са, че няма locality(при достъпване на последователни елементи в паметта, се достъпват несъседни елементи в heap-a) и се заделя многократно памет на heap-a.

<slidebreak/>

## Задачи

**Задача 1:** Да се моделира компания за отдаване на коли под наем. Всяка кола може да бъде отдадена под наем на клиент срещу определена сума пари. Да се поддържа списък с всички налични коли с опции за сортиране и филтриране.

**Задача 2:** Моделирайте клас UniversityMajor, който съдържа име, направление, университет, факултет и описание на специалност. Моделирайте клас Student, който има име, факултетен номер, специалност и оценки. Нека има възможност за добавяне на оценки, извеждане на оценките и среден успех.
