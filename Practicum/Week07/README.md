<h1 align="center">ООП - Практикум - 02.04.2025 - Седмица 07</h1>

## Задачи

### Задача 1

Реализирайте клас **Матрица** с *произволни размери*. Реализирайте:
- конструктор с параметри - 2 числа, които да определят размера на матрицата
- конструктор по подразбиране (по default размерите са 2х2)

Оператори:
-   `+=` - за събиране на матрици
-   `+`
-   `-=` - за изваждане на матрици
-   `-`
-  `*=` - за умножаване на матрици (стига да е възможно)
-   `*`
-  `*=` - за умножаване на матрица с число
-   `*`
-   `==` - 2 матрици са равни, ако всичките им елементи са равни
-   `!=`
-  `[]` - връща реда от матрицата на съответния индекс (за константен и неконстантен достъп)
- `operator bool` - връща `false`, ако матрицата е нулевата. В противен случай връща `true`. Помислете за оптимизация на този оператор. *Hint: mutable*

## Задача 2

Като програмисти, често ни се налага да работим с двоични числа.
За да си помогнем, ще си направим клас за работа с такива.

Създайте клас `BinaryNumber`, който да има:
- конструктор по подразбиране, който инициализира числото със стойността нула;
- конструктор, приемащ символен низ
  - този конструктор трябва да 'взема' двоичните цифри от първото срещане на единица в подадения низ, до последната валидна бинарна цифра
- голяма четворка
- предефинира следните оператори:
  - '`==`' – връща дали две числа са равни;
  - '`!=`' – връща дали две числа не са равни;
  - '`&`' – връща побитово `AND` на две числа;
  - '`|`' – връща побитово `OR` на две числа;
  - '`^`' – връща побитово `XOR` на две числа;
  - '`+`' – връща сбора на две числа;
  - '`<<`' – преместване надясно;
  - '`>>`' – преместване наляво;
  - '`<<`' – извеждане в поток;
  - '`>>`' – въвеждане от поток;

### Задача 3

Да се имплементира клас `Song`, който представя една песен.
- Име;
- Продължителност;
- Жанр - може да бъде прост жанр: `{ ROCK, POP, HIP-HOP, EDM, JAZZ }` или комбинация между 2 или повече прости жанра (напр. ROCK и POP)

Съдържание - последователност от байтове, която се прочита от двоични файлове

Жанрът трябва да се пази в структура/член-данна, която заема **най-много 1 байт**.

Съдържанието на песента трябва да може да се модифицира по 1 от следните начини:
Всеки **k**-ти бит отзад напред да се преобразува в 1-ца (за създаване на допълнителен ритъм)

**Пример:**

0100 0110 0100 0110, 3 -> 0**1**00 **1**11**1** 01**1**0 0**1**10

Да се миксира с друга песен - 1-ци остават всички битове, които са 1-ци в само една от двете песни (ако някой бит е 1-ца и в двете песни, то ще бъде 0-ла в резултата). 
Ако една песен се миксира с друга с различна дължина, се миксират толкова байтове, колкото е дължината на по-кратката.

**Пример:**

Песен 1: 0110 0001
Песен 2: 0101 0101
=> Песен 1: 0011 0100

Песен 1: 0101 1010 0101 1010
Песен 2: 0111  0111
=> Песен 1: 0010 1101 0101 1010

Песен 1: 0111  0111
Песен 2: 0101  1010 0101 1010
=> Песен 1: 0010 1101

Уточнение: При миксиране на дадена изходна песен с друга, миксът презаписва съдържанието на изходната песен, като дължината на съдържанието не се променя.

Жанрът се подава като стринг, където всяка буква отговаря на даден прост жанр (напр. **"rp"** означава рок и поп)

## Бонуси

### Задача 4

Напишете клас `MultiSet`, който съдържа мултимножество от числа в диапазона от `[ 0 - n-1 ]`. Стойността на **n** се приема от конструктора на класа. 
Всяко число може да се среща най-много 3 пъти в рамките на мултимножеството.

Във всеки един момент обект от вашия клас трябва да има задължително **минимален** възможен размер.

Трябва да имате следната функционалност:
* Добавяне на число, ако се среща по-малко от 3 пъти в множеството
* Премахване на число, ако се съдържа
* Проверка колко пъти се съдържа число
* Принтиране на всички числа, които съдържа множеството
* Функция, която приема две множества и връща тяхното сечение
* Функция, която приема две множества и връща тяхното обединение

