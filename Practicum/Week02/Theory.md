<h1 align="center">ООП - Практикум - 26.02.2025 - Седмица 02</h1>

## Йерархия на потоците

```plaintext
                 ios
              /        \
       istream          ostream
      /       \        /       \
  ifstream     iostream      ofstream
              /       \
        fstream      stringstream
```

Всички потоци за вход (`ifstream`) в себе си съдържат **get** указател. Всички потоци за изход (`ofstream`) в себе си съдържат **put** указател. 

В себе си `fstream` съдържа **get** и **put** указател, като при входна операция, след изходна, трябва да се прави синхронизация на потока: `flush() <=> seekg(tellg())`

## Форматиран вход и изход
- **Форматиран вход:** `<Поток за вход> >> <Обект>`
- **Форматиран изход:** `<Поток за изход> << <Обект>`

Операторите `>>` и `<<`:
- Пропускат whitespaces (`' '`), но не и newlines (`\n`)
- Връщат референция към потока, което позволява да ги **chain**-ваме

**Пример:**

```c++
std::cout << "Test product: " << 3 << " * " << 7 << " = " << 21 << std::endl;
```

- `std::cout` е обект от тип `ostream`, като това ни позволява да използваме оператор `<<`
- `std::cin` е обект от тип `istream`, като това ни позволява да използваме оператор `>>`

## Неформатиран вход и изход

### Неформатиран изход:

- `ostream& put(char ch)` - поставя символ на позицията, където сочи **put** указателя, като премества **put** указателя една позиция напред
- `ostream& write(const char* str, size)` - писане в двоичен файл

### Неформатиран вход:

- `int get()` - връща ASCII код, отговарящ на символа, към който сочи **get** указателя, като го премества една позиция напред
- `int peek()` - връща ASCII код, отговарящ на символа, към който сочи **get** указателя, като **НЕ** го мести напред
- `istream& get(<buffer>, <size>, <delimiter>)` - прочита символи от потока, докато не се прочетат **(size - 1)** на брой символа, или докато не се срещне подаденият разделител. По **default**, ако не означим разделител, се използва newline (`\n`).
- `istream& getline(<buffer>, <size>, <delimiter>)` - прочита символи от потока, докато не се прочетат **size** на брой символа, или докато не се срещне подаденият разделител. По **default**, ако не означим разделител, се използва newline (`\n`).
- `istream& read(char* str, size)` - четене от двоичен файл
- `istream& ignore()` - премества **get** указателя с една позиция
- `istream& ignore(<size>, <delimiter>)` - премества **get** указателя с **n** позиции напред, или докато срещне подадения разделител

**ВАЖНО!!!** При `.get()` разделителят не се прочита, докато при `.getline()` се прочита

## Позициониране при потоците за вход и изход

### Позициониране при потоците за изход

- `.tellp()` - връща позицията на **put** указателя
- `.seekp(<position>)` - мести **put** указателя до дадения **position**
- `.seekp(<offset>, <direction>)` - мести **put** указателя с **offset** на брой позиции спрямо **direction**

### Позициониране при потоците за вход

- `.tellg()` - връща позицията на **get** указателя
- `.seekg(<position>)` - мести **get** указателя до дадената позиция
- `.seekg(<offset>, <direction>)` -  мести **get** указателя с **offset** на брой позиции спрямо **direction**

`direction` може да бъде една от следните позиции:
- `std::ios::beg` - начало на файла
- `std::ios::cur` - текуща позиция във файла
- `std::ios::end` - край на файла

## Режими на работа

| Режим               | Описание                                                                     | Бит                |
|---------------------|------------------------------------------------------------------------------|--------------------|
| std::ios::in        | режим на четене от файл                                                      | 1 << 0             |
| std::ios::out       | режим на писане във файл                                                     | 1 << 1             |
| std::ios::ate       | премества **put** указателя накрая на файла, позволява позициониране         | 1 << 2             |
| std::ios::app       | премества **put** указателя накрая на файла, **НЕ** позволява позициониране  | 1 << 3             |
| std::ios::trunc     | ако във файла има съдържание, то се изтрива                                  | 1 << 4             |
| std::ios::binary    | двоичен режим на работа, `\n` се третира различно                            | 1 << 5             |
| std::ios::nocreate  | ако файлът съществува, го отваря                                             | 1 << 6             |
| std::ios::noreplace | ако файлът **НЕ** съществува, го отваря                                      | 1 << 7             |

### Комбиниране на режими на работа

```c++
std::ofstream ofs(<file_name>, std::ios::out | std::ios::app);
```

## Състояния на потока

```plaintext
|======================|======================-|======================-|
|        badbit        |        failbit        |        goodbit        |
|======================|======================-|======================-|
```

- `.bad()` - фатална грешка, от която потокът **НЕ** може да се възстанови
- `.fail()` - грешка, която възниква по време на работа, като потокът може да се възстанови
- `.good()` - всичко е наред
- `.eof()` - достигнат е края на файла
- `.clear()` - изчиства състоянието на потока (всички вдигнати битове)
- `operator bool()` - `!(bad ∨ fail)`

**ВАЖНО!!!** Ако се вдигне `badbit` => вдига се `failbit`
